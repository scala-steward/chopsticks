package dev.chopsticks.stream

import akka.NotUsed
import akka.stream._
import akka.stream.scaladsl.{Flow, Keep, Source}
import dev.chopsticks.fp.akka_env.AkkaEnv
import dev.chopsticks.fp.zio_ext.TaskExtensions
import zio.{Cause, Exit, RIO, UIO, ZIO, ZScope}

import scala.annotation.unchecked.uncheckedVariance
import scala.concurrent.ExecutionContextExecutor
import scala.util.{Failure, Success}

object ZAkkaFlow {
  implicit final class FlowToZAkkaFlow[-In, +Out, +Mat](flow: => Flow[In, Out, Mat]) {
    def toZAkkaFlow: ZAkkaFlow[Any, Nothing, In, Out, Mat] = {
      new ZAkkaFlow(ZAkkaFlowContext(ZScope.make[Exit[Any, Any]].map(s => flow -> ZAkkaStreamScope(s))))
    }

  }

  def withScope[In](scope: ZAkkaStreamScope): ZAkkaFlow[Any, Nothing, In, In, NotUsed] = {
    new ZAkkaFlow(ZAkkaFlowContext(ZIO.succeed((Flow[In], scope))))
  }

  def apply[R, E, In, Out, Mat](make: ZIO[R, E, Flow[In, Out, Mat]]): ZAkkaFlow[R, E, In, Out, Mat] =
    new ZAkkaFlow(ZAkkaFlowContext(
      for {
        scope <- ZScope.make[Exit[Any, Any]]
        flow <- make
      } yield {
        flow -> ZAkkaStreamScope(scope)
      }
    ))

  def apply[In]: ZAkkaFlow[Any, Nothing, In, In, NotUsed] = apply(ZIO.succeed(Flow[In]))
//
//  def apply[In, Out, Mat](flow: => Flow[In, Out, Mat]): ZAkkaFlow[Any, Nothing, In, Out, Mat] =
//    new ZAkkaFlow(ZIO.succeed(flow))

}

final case class ZAkkaStreamScope(handle: ZScope.Open[Exit[Any, Any]]) {
  def extend(child: ZScope[Exit[Any, Any]]): UIO[Boolean] = handle.scope.extend(child)
  def manage(child: ZAkkaStreamScope): UIO[ZAkkaStreamScope] = {
    child.handle.scope.extend(handle.scope)
      .as(ZAkkaStreamScope(handle.copy(close = e => child.handle.close(e) *> handle.close(e))))
  }
}

final case class ZAkkaFlowContext[R, E, In, Out, Mat](make: ZIO[R, E, (Flow[In, Out, Mat], ZAkkaStreamScope)]) {
  def map[R1 <: R, E1 >: E, Next, Mat2](fn: (
    Flow[In, Out, Mat],
    ZAkkaStreamScope
  ) => ZIO[R1, E1, Flow[In, Next, Mat2]]): ZAkkaFlowContext[R1, E1, In, Next, Mat2] = {
    new ZAkkaFlowContext[R1, E1, In, Next, Mat2](make
      .flatMap { case (flow, scope) =>
        fn(flow, scope).map(f => f -> scope)
      })
  }

  def mapScope[R1 <: R, E1 >: E, Next, Mat2](fn: (
    Flow[In, Out, Mat],
    ZAkkaStreamScope
  ) => ZIO[R1, E1, (Flow[In, Next, Mat2], ZAkkaStreamScope)]): ZAkkaFlowContext[R1, E1, In, Next, Mat2] = {
    new ZAkkaFlowContext[R1, E1, In, Next, Mat2](make
      .flatMap { case (flow, scope) =>
        fn(flow, scope)
      })
  }
}

final class ZAkkaFlow[-R, +E, -In, +Out, +Mat] private (context: ZAkkaFlowContext[R, E, In, Out, Mat]) {
  def make: ZIO[R, E, (Flow[In, Out, Mat], ZAkkaStreamScope)] = context.make

  def requireEnv: ZIO[R, E, ZAkkaFlow[Any, E, In, Out, Mat]] = make.map { case (flow, scope) =>
    new ZAkkaFlow(ZAkkaFlowContext[Any, E, In, Out, Mat](ZIO.succeed(flow -> scope)))
  }

  def mapAsync[R1 <: R, Next](parallelism: Int)(runTask: Out => RIO[R1, Next])
    : ZAkkaFlow[R1 with AkkaEnv, E, In, Next, Mat] = {
    new ZAkkaFlow(context
      .mapScope { (flow, scope) =>
        for {
          childScope <- ZScope.make[Exit[Any, Any]]
          newScope <- scope.manage(ZAkkaStreamScope(childScope))
          runtime <- ZIO.runtime[R1 with AkkaEnv]
        } yield {
          implicit val rt: zio.Runtime[R1 with AkkaEnv] = runtime
          implicit val ec: ExecutionContextExecutor = rt.environment.get[AkkaEnv.Service].dispatcher

          flow
            .mapAsync(parallelism) { a =>
              rt.unsafeRun(runTask(a).forkIn(childScope.scope)).join.unsafeRunToFuture
            }
            .watchTermination() { (mat, f) =>
              f.onComplete {
                case Failure(exception) =>
                  rt.unsafeRunAsync_(childScope.close(Exit.Failure(Cause.fail(exception))))
                case Success(value) =>
                  rt.unsafeRunAsync_(childScope.close(Exit.Success(value)))
              }
              mat
            } -> newScope
        }
      })
  }

  def mapAsyncUnordered[R1 <: R, Next](parallelism: Int)(runTask: Out => RIO[R1, Next])
    : ZAkkaFlow[R1 with AkkaEnv, E, In, Next, Mat] = {
    new ZAkkaFlow(context
      .map { (flow, scope) =>
        for {
          runtime <- ZIO.runtime[R1 with AkkaEnv]
        } yield {
          implicit val rt: zio.Runtime[R1 with AkkaEnv] = runtime
          implicit val ec: ExecutionContextExecutor = rt.environment.get[AkkaEnv.Service].dispatcher

          val newFlow = flow
            .mapAsyncUnordered(parallelism) { a =>
              rt.unsafeRun(runTask(a).forkIn(scope.handle.scope)).join.unsafeRunToFuture
            }

          newFlow
        }
      })
  }

  def switchFlatMapConcat[R1 <: R, Next](f: Out => RIO[R1, Graph[SourceShape[Next], Any]])
    : ZAkkaFlow[R1 with AkkaEnv, E, In, Next, Mat] = {
    new ZAkkaFlow(
      context.map { (flow, _) =>
        ZIO.runtime[R1 with AkkaEnv].map { implicit rt =>
          val env = rt.environment
          val akkaService = env.get[AkkaEnv.Service]
          import akkaService.actorSystem

          flow
            .statefulMapConcat(() => {
              var currentKillSwitch = Option.empty[KillSwitch]

              in => {
                currentKillSwitch.foreach(_.shutdown())

                val (ks, s) = Source
                  .fromGraph(rt.unsafeRun(f(in)))
                  .viaMat(KillSwitches.single)(Keep.right)
                  .preMaterialize()

                currentKillSwitch = Some(ks)
                List(s)
              }
            })
            .async
            .flatMapConcat(identity)
        }
      }
    )
  }

  def viaZAkkaFlow[R1 <: R, E1 >: E, Next, Mat2, Mat3](next: ZAkkaFlow[R1, E1, Out @uncheckedVariance, Next, Mat2])
    : ZAkkaFlow[R1, E1, In, Next, Mat] = {
    viaZAkkaFlowMat(next)(Keep.left)
  }

  def viaZAkkaFlowMat[R1 <: R, E1 >: E, Next, Mat2, Mat3](next: ZAkkaFlow[R1, E1, Out @uncheckedVariance, Next, Mat2])(
    combine: (Mat, Mat2) => Mat3
  ): ZAkkaFlow[R1, E1, In, Next, Mat3] = {
    new ZAkkaFlow(
      ZAkkaFlowContext(
        for {
          ctx1 <- context.make
          (flow, scope) = ctx1
          ctx2 <- next.make
          (nextFlow, childScope) = ctx2
          newScope <- scope.manage(childScope)
        } yield {
          val newFlow = flow
            .viaMat(nextFlow)(combine)

          newFlow -> newScope
        }
      )
    )
  }

  def via[Next](flow: => Graph[FlowShape[Out, Next], Any]): ZAkkaFlow[R, E, In, Next, Mat] = {
    viaMat(flow)(Keep.left)
  }

  def viaBuilder[Next](makeFlow: Flow[Out @uncheckedVariance, Out, NotUsed] => Graph[FlowShape[Out, Next], Any])
    : ZAkkaFlow[R, E, In, Next, Mat] = {
    viaBuilderMat(makeFlow)(Keep.left)
  }

  def viaMat[Next, Mat2, Mat3](flow: => Graph[FlowShape[Out, Next], Mat2])(
    combine: (Mat, Mat2) => Mat3
  ): ZAkkaFlow[R, E, In, Next, Mat3] = {
    viaBuilderMat(_ => flow)(combine)
  }

  def viaBuilderMat[Next, Mat2, Mat3](makeFlow: Flow[Out @uncheckedVariance, Out, NotUsed] => Graph[
    FlowShape[Out, Next],
    Mat2
  ])(
    combine: (Mat, Mat2) => Mat3
  ): ZAkkaFlow[R, E, In, Next, Mat3] = {
    new ZAkkaFlow[R, E, In, Next, Mat3](
      context.map { (flow, _) =>
        UIO(flow.viaMat(makeFlow(Flow[Out]))(combine))
      }
    )
  }

  def viaM[R1 <: R, E1 >: E, Next](makeFlow: ZIO[R1, E1, Graph[FlowShape[Out, Next], Any]])
    : ZAkkaFlow[R1, E1, In, Next, Mat] = {
    viaMatM(makeFlow)(Keep.left)
  }

  def viaBuilderM[R1 <: R, E1 >: E, Next](makeFlow: Flow[Out @uncheckedVariance, Out, NotUsed] => ZIO[
    R1,
    E1,
    Graph[FlowShape[Out, Next], Any]
  ]): ZAkkaFlow[R1, E1, In, Next, Mat] = {
    viaMatM(makeFlow(Flow[Out]))(Keep.left)
  }

  def viaMatM[R1 <: R, E1 >: E, Next, Mat2, Mat3](makeFlow: ZIO[R1, E1, Graph[FlowShape[Out, Next], Mat2]])(
    combine: (Mat, Mat2) => Mat3
  ): ZAkkaFlow[R1, E1, In, Next, Mat3] = {
    new ZAkkaFlow(
      context.map { (flow, _) =>
        makeFlow.map(nextFlow => flow.viaMat(nextFlow)(combine))
      }
    )
  }

  def viaBuilderMatM[R1 <: R, E1 >: E, Next, Mat2, Mat3](makeFlow: Flow[Out @uncheckedVariance, Out, NotUsed] => ZIO[
    R1,
    E1,
    Graph[FlowShape[Out, Next], Mat2]
  ])(
    combine: (Mat, Mat2) => Mat3
  ): ZAkkaFlow[R1, E1, In, Next, Mat3] = {
    viaMatM(makeFlow(Flow[Out]))(combine)
  }

  def interruptible: ZAkkaFlow[R, E, In, Out, UniqueKillSwitch] = {
    new ZAkkaFlow[R, E, In, Out, UniqueKillSwitch](
      context.map { (flow, _) =>
        UIO(flow.viaMat(KillSwitches.single)(Keep.right))
      }
    )
  }
}
